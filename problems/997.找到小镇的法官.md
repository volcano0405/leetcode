#  997. 找到小镇的法官

- 题目难度：中等
- [题目链接](https://leetcode-cn.com/problems/find-the-town-judge/)
## 一、题目描述


在一个小镇里，按从`1` 到 `n` 为 `n` 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。
如果小镇的法官真的存在，那么：

   - 小镇的法官不相信任何人
   - 每个人(除了小镇法官外) 都信任小镇的法官。
   - 只有一个人同时满足条件1和条件2。

​

给定数组 `trust`，该数组由信任对 `trust[i] = [a,b]` 组成，表示编号为 `a` 的人信任编号为`b`的人。
​

如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则返回 `-1` 。
​

#### 大白话解释
我们需要在`n` 个人找到是否存在一个秘密法官，通过以下规则：

   - 小镇的法官不相信任何人，即假定`k` 为法官的话，则 `trust[k] = []`
   - 每个人(除了小镇法官外) 都信任小镇的法官，即假定`k`为法官的话，则每个人信任人员中都会存在 `k`(除了法官外)。则存在相信法官的有`n - 1`人，法官相信的为 `0` 人。
   - 只有一个人同时满足条件1和条件2，这个人就是法官。



#### 示例说明

- 示例 1：
```java
输入：n = 2,trust = [[1,2]]
输出：2
解释：
1. n = 2,表示存在2个人
2. trust[0] = [1,2] 表示编号为 1 的人相信编号为 2 的人
   turst只有一个元素，但是 n = 2，所以 编号为 2 的不相信任何人(法官)
综上，输出为 2
```

- 示例 2：
```java
输入：n = 3,trust = [[1,2],[2,3]]
输出：-1
    
解释：
1. n = 3,表示存在 3 个人
2. trust[0] = [1,2] 表示编号为 1 的人相信编号为 2 的人
   trust[1] = [2,3] 表示编号为 2 的人相信标号为 3 的人
   不满足条件 2，每个人(除法官外)都相信法官。
综上输出为 -1
```
## 二、算法实现
利用有向图的入度和出度的概念。
`trust[i] = [a,b]`，看作是`a`指向`b`的有向边。及`a` 的出度 -1，`b`的入度 +1。
根据上述条件我们知道，

- 除了法官存在所有人都选择相信法官，则法官的入度为 `n - 1`.
- 法官不相信任何人，则法官的出度为 `0`
```java
public int findJudge(int n,int[][] trust){

    int[] inDegrees = new int[n + 1];
    int[] outDegrees = new int[n + 1];
    
    for(int i = 0;i < trust.length;i++){
    	int x = trust[i][0],y = trust[i][1];
        ++inDegrees[y];//# 选择信任法官的人
        ++outDegreest[x];//# 法官信任的人
    }
    
    for(int i = 1;i <= n;i++){
    	if(inDegrees[i] == n - 1 && outDegreest[i] == 0){
        	return i;
        }
    }
    
    return -1;
}
```
